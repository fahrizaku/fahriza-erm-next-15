// Prisma schema
// Generator dan Datasource
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Model Patient
model Patient {
  id              Int       @id @default(autoincrement())
  no_rm           Int       @unique
  name            String
  gender          String?
  birthDate       DateTime?
  address         String?
  isBPJS          Boolean
  no_bpjs         String?   @unique
  nik             String?   @unique
  phoneNumber     String?   
  createdAt       DateTime? @default(now())
  updatedAt       DateTime? @updatedAt

    // Relations
  screenings      Screening[]
  medicalRecords  MedicalRecord[]
}

model DrugStoreProduct {
  id            Int         @id @default(autoincrement()) 
  name          String
  category      String?
  manufacturer  String?
  purchasePrice Decimal?
  price         Decimal
  stock         Int
  expiryDate    String?
  unit          String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([name])
  @@index([category])
  @@index([manufacturer])
  @@index([expiryDate])
}

model DrugPrescription {
  id            Int         @id @default(autoincrement()) 
  name          String
  category      String?
  manufacturer  String?
  purchasePrice Decimal?
  price         Decimal
  stock         Int
  expiryDate    String?
  unit          String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([name])
  @@index([category])
  @@index([manufacturer])
  @@index([expiryDate])
}

// Screening model for initial patient assessment
model Screening {
  id                Int           @id @default(autoincrement())
  patientId         Int
  patient           Patient       @relation(fields: [patientId], references: [id])
  complaints        String        // Patient's complaints
  temperature       Decimal?      // Body temperature
  systolicBP        Int?          // Systolic blood pressure (e.g., 120 in "120/80")
  diastolicBP       Int?          // Diastolic blood pressure (e.g., 80 in "120/80")
  pulse             Int?          // Heart rate
  respiratoryRate   Int?          // Breathing rate
  weight            Decimal?      // Weight in kg
  height            Int?          // Height in cm
  waistCircumference Decimal?     // Lingkar pinggang in cm
  oxygenSaturation  Decimal?      // Saturasi oksigen in percentage
  isBPJSActive      Boolean?      // Status BPJS aktif atau tidak
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  // Screening status
  status            String        @default("waiting") // waiting, in-progress, completed
  queueNumber       Int?
  
  // Relations
  medicalRecord     MedicalRecord?
  
  @@index([patientId])
  @@index([status])
  @@index([createdAt])
}

// Queue model for managing patient queue
model OutpatientQueue {
  id                Int           @id @default(autoincrement())
  screeningId       Int           @unique
  queueNumber       Int
  status            String        @default("waiting") // waiting, called, in-progress, completed
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  @@index([status])
  @@index([createdAt])
}

// Medical Record model for storing complete patient visit data
model MedicalRecord {
  id                Int           @id @default(autoincrement())
  patientId         Int
  patient           Patient       @relation(fields: [patientId], references: [id])
  screeningId       Int           @unique
  screening         Screening     @relation(fields: [screeningId], references: [id])
  
  // Doctor's examination
  diagnosis         String?       // Diagnosis description
  icdCode           String?       // ICD-10 code
  clinicalNotes     String?       // Additional clinical notes
  
  // Visit metadata
  visitType         String        @default("outpatient") // outpatient, inpatient
  visitDate         DateTime      @default(now())
  doctorName        String?
  
  // Relations
  prescriptions     Prescription[]  // Changed from Prescription? to Prescription[]
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  @@index([patientId])
  @@index([visitDate])
  @@index([icdCode])
}

// Prescription models
model Prescription {
  id                Int               @id @default(autoincrement())
  medicalRecordId   Int               
  medicalRecord     MedicalRecord     @relation(fields: [medicalRecordId], references: [id])
  items             PrescriptionItem[]
  notes             String?           // Additional notes about the prescription
  prescriptionType  String?           // Type of prescription (e.g., "Main", "Follow-up", "Alternative", "Racikan")
  dosage            String?           // Shared dosage instruction for racikan prescriptions
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([medicalRecordId])
}

model PrescriptionItem {
  id                Int               @id @default(autoincrement())
  prescriptionId    Int
  prescription      Prescription      @relation(fields: [prescriptionId], references: [id])
  manualDrugName    String?           // For manual entry when drug not in system
  dosage            String?           // Individual dosage (only used for non-racikan prescriptions)
  quantity          Int
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([prescriptionId])
}

model PharmacyQueue {
  id                Int               @id @default(autoincrement())
  medicalRecordId   Int               @unique
  queueNumber       Int
  status            String            @default("waiting") // waiting, preparing, ready, dispensed
  pharmacistName    String?           // Name of the pharmacist handling the prescription
  notes             String?           // Any special notes for the pharmacist
  startedAt         DateTime?         // When preparation began
  completedAt       DateTime?         // When preparation was completed
  dispensedAt       DateTime?         // When medication was given to patient
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([status])
  @@index([createdAt])
  @@index([queueNumber])
}

// ICD-10 lookup table for diagnosis codes
model IcdCode {
  id                Int           @id @default(autoincrement())
  code              String        @unique
  description       String
  version           String?
  
  @@index([code])
}

// /app/api/screenings/route.js
import { NextResponse } from "next/server";
import { db } from "@/lib/db";

// Create a new screening entry
export async function POST(request) {
  try {
    const data = await request.json();

    // Validate required fields
    if (!data.patientId || !data.complaints) {
      return NextResponse.json(
        { success: false, message: "Missing required fields" },
        { status: 400 }
      );
    }

    // If trying to update patient with BPJS, check if the BPJS number already exists
    if (data.isBPJSActive && data.no_bpjs && data.updatePatientBPJS) {
      // Check if BPJS number already exists for another patient
      const existingPatient = await db.patient.findFirst({
        where: {
          no_bpjs: data.no_bpjs,
          id: {
            not: data.patientId, // Exclude current patient
          },
        },
      });

      if (existingPatient) {
        return NextResponse.json(
          {
            success: false,
            message: "Nomor BPJS telah terdaftar pada pasien lain",
          },
          { status: 400 }
        );
      }
    }

    // Generate a queue number (get highest queue number for today + 1)
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const latestQueue = await db.outpatientQueue.findFirst({
      where: {
        createdAt: {
          gte: today,
        },
      },
      orderBy: {
        queueNumber: "desc",
      },
    });

    const queueNumber = latestQueue ? latestQueue.queueNumber + 1 : 1;

    // If isBPJSActive is true and the patient doesn't have BPJS information,
    // update patient record with BPJS number
    if (data.isBPJSActive && data.no_bpjs && data.updatePatientBPJS) {
      await db.patient.update({
        where: { id: data.patientId },
        data: {
          isBPJS: true,
          no_bpjs: data.no_bpjs,
        },
      });
    }

    // Create the screening entry with the updated schema fields
    const screening = await db.screening.create({
      data: {
        patientId: data.patientId,
        complaints: data.complaints,
        temperature: data.temperature ? parseFloat(data.temperature) : null,
        systolicBP: data.systolicBP ? parseInt(data.systolicBP) : null,
        diastolicBP: data.diastolicBP ? parseInt(data.diastolicBP) : null,
        pulse: data.pulse ? parseInt(data.pulse) : null,
        respiratoryRate: data.respiratoryRate
          ? parseInt(data.respiratoryRate)
          : null,
        weight: data.weight ? parseFloat(data.weight) : null,
        height: data.height ? parseInt(data.height) : null,
        waistCircumference: data.waistCircumference
          ? parseFloat(data.waistCircumference)
          : null,
        oxygenSaturation: data.oxygenSaturation
          ? parseFloat(data.oxygenSaturation)
          : null,
        isBPJSActive: data.isBPJSActive || false,
        status: "waiting",
        queueNumber: queueNumber,
      },
    });

    // Create a queue entry
    await db.outpatientQueue.create({
      data: {
        screeningId: screening.id,
        queueNumber: queueNumber,
        status: "waiting",
      },
    });

    return NextResponse.json({
      success: true,
      screening,
      queueNumber,
    });
  } catch (error) {
    console.error("Error creating screening:", error);
    return NextResponse.json(
      {
        success: false,
        message: "Failed to create screening",
        error: error.message,
      },
      { status: 500 }
    );
  }
}


// /app/api/medical-records/route.js
import { NextResponse } from "next/server";
import { db } from "@/lib/db";

export async function POST(request) {
  try {
    const data = await request.json();

    // Validate required fields
    if (
      !data.patientId ||
      !data.screeningId ||
      !data.diagnosis ||
      !data.doctorName
    ) {
      return NextResponse.json(
        { success: false, message: "Missing required fields" },
        { status: 400 }
      );
    }

    // Create medical record first
    const medicalRecord = await db.medicalRecord.create({
      data: {
        patientId: data.patientId,
        screeningId: data.screeningId,
        diagnosis: data.diagnosis,
        icdCode: data.icdCode || null,
        clinicalNotes: data.clinicalNotes || null,
        doctorName: data.doctorName,
        visitType: "outpatient",
      },
    });

    // Handle prescriptions (now supporting multiple and racikan type)
    if (
      data.prescriptions &&
      Array.isArray(data.prescriptions) &&
      data.prescriptions.length > 0
    ) {
      // Create each prescription
      for (const prescriptionData of data.prescriptions) {
        // Validate prescription data
        if (!prescriptionData.items || !Array.isArray(prescriptionData.items)) {
          continue; // Skip invalid prescription
        }

        // Check if this is a racikan prescription
        const isRacikan = prescriptionData.type === "Racikan";

        // Create prescription
        await db.prescription.create({
          data: {
            medicalRecordId: medicalRecord.id,
            notes: prescriptionData.notes || null,
            prescriptionType: prescriptionData.type || null,
            // Add the dosage field for racikan prescriptions
            dosage: isRacikan ? prescriptionData.dosage : null,
            items: {
              create: prescriptionData.items.map((item) => ({
                manualDrugName: item.manualDrugName,
                // For racikan items, don't store individual dosages
                // For regular prescriptions, store dosage at item level
                dosage: isRacikan ? null : item.dosage,
                quantity: item.quantity,
              })),
            },
          },
        });
      }
    } else if (data.prescription) {
      // For backward compatibility - handle single prescription
      await db.prescription.create({
        data: {
          medicalRecordId: medicalRecord.id,
          notes: data.prescription.notes || null,
          prescriptionType: data.prescription.type || "Main",
          items: {
            create: data.prescription.items.map((item) => ({
              manualDrugName: item.manualDrugName,
              drugId: item.drugId || null,
              dosage: item.dosage,
              quantity: item.quantity,
            })),
          },
        },
      });
    }

    // Update screening status to "completed"
    await db.screening.update({
      where: {
        id: data.screeningId,
      },
      data: {
        status: "completed",
      },
    });

    // Update queue status
    await db.outpatientQueue.updateMany({
      where: {
        screeningId: data.screeningId,
      },
      data: {
        status: "completed",
      },
    });

    return NextResponse.json({
      success: true,
      medicalRecordId: medicalRecord.id,
    });
  } catch (error) {
    console.error("Error creating medical record:", error);
    return NextResponse.json(
      { success: false, message: "Failed to create medical record" },
      { status: 500 }
    );
  }
}

// GET endpoint for retrieving all medical records - updated to include dosage field
export async function GET(request) {
  try {
    // Membaca query parameters
    const { searchParams } = new URL(request.url);
    const search = searchParams.get("search");
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");

    // Menghitung offset untuk pagination
    const skip = (page - 1) * limit;

    // Membuat kondisi filter
    const where = {};

    if (search) {
      where.OR = [
        {
          patient: {
            name: {
              contains: search,
              mode: "insensitive",
            },
          },
        },
        {
          patient: {
            no_rm: {
              equals: isNaN(parseInt(search)) ? undefined : parseInt(search),
            },
          },
        },
        {
          patient: {
            nik: {
              contains: search,
            },
          },
        },
      ];
    }

    // Filter tanggal kunjungan
    if (startDate || endDate) {
      where.visitDate = {};

      if (startDate) {
        where.visitDate.gte = new Date(startDate);
      }

      if (endDate) {
        // Atur waktu ke akhir hari
        const endDateTime = new Date(endDate);
        endDateTime.setHours(23, 59, 59, 999);
        where.visitDate.lte = endDateTime;
      }
    }

    // Mengambil total count untuk pagination
    const totalCount = await db.medicalRecord.count({ where });

    // Mengambil data berdasarkan filter
    const medicalRecords = await db.medicalRecord.findMany({
      where,
      include: {
        patient: true,
        screening: true,
        prescriptions: {
          include: {
            items: {
              include: {
                drug: true,
              },
            },
          },
        },
      },
      orderBy: {
        visitDate: "desc",
      },
      skip,
      take: limit,
    });

    return NextResponse.json({
      data: medicalRecords,
      meta: {
        total: totalCount,
        page,
        limit,
        totalPages: Math.ceil(totalCount / limit),
      },
    });
  } catch (error) {
    console.error("Error fetching medical records:", error);
    return NextResponse.json(
      { error: "Failed to fetch medical records" },
      { status: 500 }
    );
  } finally {
    await db.$disconnect();
  }
}


saya ingin untuk medical record, setelah selesai di buat menambahkan antrian, tapi antrian farmasi

ini adalah contoh antrian
"use client";

import React, { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { ChevronLeft } from "lucide-react";
import { toast } from "react-toastify";
import QueueHeader from "./_components/QueueHeader";
import QueueFilters from "./_components/QueueFilters";
import QueueCards from "./_components/QueueCards";
import { LoadingState, EmptyState, ErrorState } from "./_components/UIStates";

export default function OutpatientQueuePage() {
  const router = useRouter();

  const [queueList, setQueueList] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState(null);
  const [filter, setFilter] = useState("all"); // waiting, called, in-progress, completed
  const [searchTerm, setSearchTerm] = useState("");

  // Fetch queue data
  const fetchQueueData = async () => {
    try {
      const isRefreshing = refreshing;
      if (!isRefreshing) setLoading(true);

      const response = await fetch(`/api/outpatient/queue?status=${filter}`);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        setQueueList(data.queue);
      } else {
        setError(data.message || "Failed to fetch queue data");
        toast.error(data.message || "Failed to fetch queue data");
      }
    } catch (error) {
      console.error("Error fetching queue:", error);
      setError("An error occurred while fetching queue data");
      if (!refreshing) {
        toast.error("An error occurred while fetching queue data");
      }
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    fetchQueueData();

    // Set up interval to refresh data every 30 seconds
    const interval = setInterval(() => {
      setRefreshing(true);
      fetchQueueData();
    }, 30000);

    return () => clearInterval(interval);
  }, [filter]);

  // Handle manual refresh
  const handleRefresh = () => {
    setRefreshing(true);
    fetchQueueData();
  };

  // Handle calling a patient (only changes status to "called")
  const handleCallPatient = async (screeningId) => {
    try {
      const response = await fetch(
        `/api/outpatient/queue/${screeningId}/call`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        // Update the queue list
        setQueueList(
          queueList.map((item) =>
            item.screeningId === screeningId
              ? { ...item, status: "called" }
              : item
          )
        );

        toast.success(`Pasien ${data.patientName} berhasil dipanggil`);
      } else {
        toast.error(data.message || "Failed to call patient");
      }
    } catch (error) {
      console.error("Error calling patient:", error);
      toast.error("An error occurred while calling patient");
    }
  };

  // Handle examining a patient (change status to "in-progress" and redirect)
  const handleExaminePatient = async (screeningId) => {
    try {
      const response = await fetch(
        `/api/outpatient/queue/${screeningId}/examine`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.success) {
        // Update the queue list
        setQueueList(
          queueList.map((item) =>
            item.screeningId === screeningId
              ? { ...item, status: "in-progress" }
              : item
          )
        );

        toast.success(`Pasien ${data.patientName} sedang diperiksa`);

        // Redirect to doctor's examination page
        router.push(`/rawat-jalan/pemeriksaan-dokter/${screeningId}`);
      } else {
        toast.error(data.message || "Failed to examine patient");
      }
    } catch (error) {
      console.error("Error examining patient:", error);
      toast.error("An error occurred while examining patient");
    }
  };

  // Filter queue items based on search term
  const filteredQueue = queueList.filter(
    (item) =>
      item.patientName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (item.queueNumber?.toString() || "").includes(searchTerm)
  );

  // Group queue items by status when filter is "all"
  const getGroupedQueue = () => {
    if (filter !== "all") return [{ status: filter, items: filteredQueue }];

    // Define the order of status groups
    const statusOrder = ["in-progress", "called", "waiting", "completed"];

    // Group items by status
    const groupedByStatus = filteredQueue.reduce((groups, item) => {
      const group = groups[item.status] || [];
      group.push(item);
      groups[item.status] = group;
      return groups;
    }, {});

    // Convert to array ordered by our status priority
    return statusOrder
      .filter(
        (status) =>
          groupedByStatus[status] && groupedByStatus[status].length > 0
      )
      .map((status) => ({
        status,
        items: groupedByStatus[status].sort(
          (a, b) => a.queueNumber - b.queueNumber
        ),
      }));
  };

  // Get status text for display
  const getStatusText = (status) => {
    switch (status) {
      case "waiting":
        return "Menunggu";
      case "called":
        return "Dipanggil";
      case "in-progress":
        return "Sedang Diperiksa";
      case "completed":
        return "Selesai";
      default:
        return status;
    }
  };

  const groupedQueue = getGroupedQueue();

  return (
    <div className="max-w-6xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
      {/* Back button */}
      <div className="mb-6">
        <Link
          href="/pasien"
          className="inline-flex items-center text-blue-600 hover:text-blue-800 transition-colors font-medium"
        >
          <ChevronLeft className="h-5 w-5" />
          <span>Kembali ke Daftar Pasien</span>
        </Link>
      </div>

      {/* Main content */}
      <div className="bg-white rounded-xl shadow-md border border-gray-200 overflow-hidden">
        {/* Header */}
        <QueueHeader
          title="Antrian Rawat Jalan"
          subtitle="Kelola antrian pasien yang telah melalui skrining"
          onRefresh={handleRefresh}
          refreshing={refreshing}
        />

        {/* Filters and search */}
        <QueueFilters
          filter={filter}
          setFilter={setFilter}
          searchTerm={searchTerm}
          setSearchTerm={setSearchTerm}
        />

        {/* Queue list */}
        <div className="p-4">
          {loading ? (
            <LoadingState message="Memuat data antrian..." />
          ) : error ? (
            <ErrorState error={error} />
          ) : filteredQueue.length === 0 ? (
            <EmptyState
              message={`Tidak ada pasien dalam antrian ${
                filter !== "all" ? getStatusText(filter).toLowerCase() : ""
              }`}
            />
          ) : (
            <div>
              {groupedQueue.map((group, index) => (
                <div key={group.status} className={index > 0 ? "mt-8" : ""}>
                  {filter === "all" && (
                    <h3 className="text-lg font-medium text-gray-900 mb-3 pb-2 border-b">
                      {getStatusText(group.status)}
                    </h3>
                  )}
                  <QueueCards
                    queueData={group.items}
                    onCallPatient={handleCallPatient}
                    onExaminePatient={handleExaminePatient}
                    router={router}
                  />
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// _components/QueueCards.js
import React from "react";
import {
  Clock,
  User,
  PhoneCall,
  Stethoscope,
  CheckCircle,
  CreditCard,
  MapPin,
} from "lucide-react";

export default function QueueCards({
  queueData,
  onCallPatient,
  onExaminePatient,
}) {
  const getStatusBadge = (status) => {
    switch (status) {
      case "waiting":
        return (
          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">
            <Clock className="w-3 h-3 mr-1" />
            Menunggu
          </span>
        );
      case "called":
        return (
          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
            <PhoneCall className="w-3 h-3 mr-1" />
            Dipanggil
          </span>
        );
      case "in-progress":
        return (
          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-indigo-100 text-indigo-800">
            <Stethoscope className="w-3 h-3 mr-1" />
            Sedang Diperiksa
          </span>
        );
      case "completed":
        return (
          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
            <CheckCircle className="w-3 h-3 mr-1" />
            Selesai
          </span>
        );
      default:
        return (
          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
            {status}
          </span>
        );
    }
  };

  const getActionButton = (item) => {
    switch (item.status) {
      case "waiting":
        return (
          <button
            onClick={() => onCallPatient(item.screeningId)}
            className="inline-flex items-center px-3 py-1.5 text-xs font-medium rounded text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            <PhoneCall className="w-3 h-3 mr-1" />
            Panggil
          </button>
        );
      case "called":
        return (
          // <button
          //   onClick={() => onExaminePatient(item.screeningId)}
          //   className="inline-flex items-center px-3 py-1.5 text-xs font-medium rounded text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          // >
          //   <Stethoscope className="w-3 h-3 mr-1" />
          //   Periksa
          // </button>
          <></>
        );
      case "in-progress":
        return (
          // <button
          //   onClick={() => onExaminePatient(item.screeningId)}
          //   className="inline-flex items-center px-3 py-1.5 text-xs font-medium rounded text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          // >
          //   <Stethoscope className="w-3 h-3 mr-1" />
          //   Lanjutkan
          // </button>
          <></>
        );
      default:
        return null;
    }
  };

  // Helper function to calculate age from birthDate
  const calculateAge = (birthDate) => {
    if (!birthDate) return "N/A";
    const today = new Date();
    const birth = new Date(birthDate);
    let age = today.getFullYear() - birth.getFullYear();
    const monthDiff = today.getMonth() - birth.getMonth();

    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birth.getDate())
    ) {
      age--;
    }

    return age;
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {queueData.map((item) => (
        <div
          key={item.screeningId}
          className="bg-white border border-gray-200 rounded-lg shadow-sm"
        >
          <div className="flex justify-between items-center px-3 py-2 border-b border-gray-200 bg-gray-50 rounded-t-lg">
            <div className="flex items-center space-x-2">
              <div className="inline-flex items-center justify-center h-6 w-6 bg-blue-100 text-blue-800 rounded-full text-xs font-semibold">
                {item.queueNumber}
              </div>
              <h3 className="text-sm font-medium text-gray-900">
                {item.patientName}
              </h3>
            </div>
            <div>{getStatusBadge(item.status)}</div>
          </div>

          <div className="p-3">
            <div className="space-y-2 text-sm">
              <div className="flex items-center">
                <User className="h-4 w-4 text-gray-500 mr-2" />
                <p>
                  {item.gender || "N/A"} Â· {calculateAge(item.birthDate)} tahun
                </p>
              </div>

              <div className="flex items-start">
                <MapPin className="h-4 w-4 text-gray-500 mr-2 mt-0.5" />
                <p className="line-clamp-2">{item.address || "N/A"}</p>
              </div>

              <div className="flex items-center">
                <CreditCard className="h-4 w-4 text-gray-500 mr-2" />
                <div className="flex items-center">
                  <span className="text-xs text-gray-500">
                    Tipe Pembayaran:
                  </span>
                  {item.isBPJSActive ? (
                    <span className="ml-1 px-1.5 py-0.5 bg-green-100 text-green-800 font-medium rounded text-xs">
                      BPJS
                    </span>
                  ) : (
                    <span className="ml-1 font-medium text-gray-900">Umum</span>
                  )}
                </div>
              </div>
            </div>

            <div className="mt-3 pt-2 border-t border-gray-200 flex justify-end">
              {getActionButton(item)}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}


